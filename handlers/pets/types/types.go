package types

import (
	"fmt"
	"regexp"
	"strconv"

	"github.com/ufukty/gohandlers/pkg/types/basics"
)

// you might opt to define your column/field types on
// top of [basics.String], [basics.Int] and [basics.Boolean]
// since they already provide most basic (de)serialization helpers
type (
	PetId   basics.String
	PetName basics.String
	PetTag  basics.String
)

// the next section of helpers are meant to be called by
// Parse, Build or Write methods defined on binding types.
//
// if you don't have custom rules and only need basic
// (de)serialization for them, then you can just call:
//   - [basics.String.FromRoute],
//   - [basics.String.ToRoute],
//   - [basics.String.FromQuery],
//   - [basics.String.ToQuery],
//   - [basics.String.FromForm] and
//   - [basics.String.ToForm]
// underneath if you prefer so; and don't have
// custom rules for those.

func (id *PetId) FromRoute(s string) error     { return (*basics.String)(id).FromRoute(s) }
func (name *PetName) FromRoute(s string) error { return (*basics.String)(name).FromRoute(s) }
func (tag *PetTag) FromRoute(s string) error   { return (*basics.String)(tag).FromRoute(s) }

func (id PetId) ToRoute() (string, error)     { return (basics.String)(id).ToRoute() }
func (name PetName) ToRoute() (string, error) { return (basics.String)(name).ToRoute() }
func (tag PetTag) ToRoute() (string, error)   { return (basics.String)(tag).ToRoute() }

func (id *PetId) FromQuery(s string) error     { return (*basics.String)(id).FromQuery(s) }
func (name *PetName) FromQuery(s string) error { return (*basics.String)(name).FromQuery(s) }
func (tag *PetTag) FromQuery(s string) error   { return (*basics.String)(tag).FromQuery(s) }

func (id PetId) ToQuery() (string, bool, error)     { return (basics.String)(id).ToQuery() }
func (name PetName) ToQuery() (string, bool, error) { return (basics.String)(name).ToQuery() }
func (tag PetTag) ToQuery() (string, bool, error)   { return (basics.String)(tag).ToQuery() }

// validation helpers are meant to be called by validation helpers
// generated by gohandlers on request binding types.

var uuid = reggy{regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$`)}
var word = reggy{regexp.MustCompile(`^\w+$`)}

func (pid PetId) Validate() error    { return uuid.Validate(string(pid)) }
func (name PetName) Validate() error { return word.Validate(string(name)) }
func (tag PetTag) Validate() error   { return word.Validate(string(tag)) }

// there is an example with non-string underlying type and
// has custom validation rule based on the API rate limits
type ListLimit int

// notice this is the first instance where [FromQuery] handler
// has possibility to return an error to caller
func (ll *ListLimit) FromQuery(s string) error {
	i, err := strconv.Atoi(s)
	if err != nil {
		return fmt.Errorf("atoi: %w", err)
	}
	*ll = ListLimit(i)
	return nil
}

func (ll ListLimit) ToQuery() (string, bool, error) {
	return strconv.Itoa(int(ll)), ll != 0, nil
}

func (ll ListLimit) Validate() error {
	if ll <= 0 {
		return fmt.Errorf("too small")
	}
	if ll > 10 {
		return fmt.Errorf("too big")
	}
	return nil
}
